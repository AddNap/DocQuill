#!/usr/bin/env python3
"""
Audit paragraph indent regression by comparing DOCX source metrics with exported CSV.

The script re-computes paragraph indentation metrics directly from the DOCX using the
layout pipeline and compares them against the CSV generated by export_paragraph_indents.py.

Exit code 0  -> no differences above tolerance
Exit code 1  -> mismatches detected or structural issues (missing/excess rows)
"""

from __future__ import annotations

import argparse
import csv
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Tuple

# Ensure project root and scripts directory are importable
ROOT_DIR = Path(__file__).resolve().parents[1]
SCRIPTS_DIR = Path(__file__).resolve().parent
if str(SCRIPTS_DIR) not in sys.path:
    sys.path.insert(0, str(SCRIPTS_DIR))
if str(ROOT_DIR) not in sys.path:
    sys.path.insert(0, str(ROOT_DIR))

from export_paragraph_indents import collect_paragraph_metrics  # type: ignore


FLOAT_FIELDS = [
    "block_x_pt",
    "block_width_pt",
    "left_indent_pt",
    "first_line_pt",
    "hanging_pt",
    "number_position_pt",
    "text_position_pt",
]
COMPARISON_FLOAT_FIELDS = [
    "left_indent_pt",
    "first_line_pt",
    "hanging_pt",
    "number_position_pt",
    "text_position_pt",
]
INT_FIELDS = [
    "paragraph_index",
    "page",
]
BOOL_FIELDS = [
    "has_marker",
]


@dataclass
class Difference:
    index: int
    field: str
    expected: str
    actual: str
    abs_delta: float | None = None


def _parse_bool(value: str) -> bool:
    if isinstance(value, bool):
        return value
    lowered = str(value).strip().lower()
    if lowered in {"1", "true", "yes"}:
        return True
    if lowered in {"0", "false", "no", "", "none"}:
        return False
    return bool(value)


def _parse_float(value: str | float | int) -> float:
    if isinstance(value, (float, int)):
        return float(value)
    text = str(value).strip()
    if not text:
        return 0.0
    try:
        return float(text)
    except ValueError:
        return 0.0


def load_csv_rows(csv_path: Path) -> Dict[int, Dict[str, object]]:
    with csv_path.open("r", newline="", encoding="utf-8") as handle:
        reader = csv.DictReader(handle)
        rows: Dict[int, Dict[str, object]] = {}
        for raw_row in reader:
            row: Dict[str, object] = dict(raw_row)
            for key in FLOAT_FIELDS:
                if key in row:
                    row[key] = _parse_float(row[key])
            for key in INT_FIELDS:
                if key in row:
                    try:
                        row[key] = int(float(row[key]))
                    except (ValueError, TypeError):
                        row[key] = 0
            for key in BOOL_FIELDS:
                if key in row:
                    row[key] = _parse_bool(row[key])
            idx = int(row.get("paragraph_index", len(rows)))
            rows[idx] = row
    return rows


def compare_rows(
    expected_rows: Iterable[Dict[str, object]],
    actual_map: Dict[int, Dict[str, object]],
    tolerance: float,
) -> Tuple[List[Difference], List[int], List[int]]:
    differences: List[Difference] = []
    missing: List[int] = []

    for expected in expected_rows:
        idx = int(expected.get("paragraph_index", -1))
        actual = actual_map.get(idx)
        if actual is None:
            missing.append(idx)
            continue

        for field in COMPARISON_FLOAT_FIELDS:
            if field not in expected or field not in actual:
                continue
            exp_val = _parse_float(expected[field])
            act_val = _parse_float(actual[field])
            delta = abs(exp_val - act_val)
            if delta > tolerance:
                differences.append(
                    Difference(
                        index=idx,
                        field=field,
                        expected=f"{exp_val:.3f}",
                        actual=f"{act_val:.3f}",
                        abs_delta=delta,
                    )
                )

        # Boolean/string comparisons for markers
        exp_has_marker = _parse_bool(expected.get("has_marker", False))
        act_has_marker = _parse_bool(actual.get("has_marker", False))
        if exp_has_marker != act_has_marker:
            differences.append(
                Difference(
                    index=idx,
                    field="has_marker",
                    expected=str(exp_has_marker),
                    actual=str(act_has_marker),
                )
            )

        exp_marker = str(expected.get("marker_text", "") or "").strip()
        act_marker = str(actual.get("marker_text", "") or "").strip()
        if exp_marker != act_marker:
            differences.append(
                Difference(
                    index=idx,
                    field="marker_text",
                    expected=exp_marker or "''",
                    actual=act_marker or "''",
                )
            )

        exp_hidden = str(expected.get("hidden_marker", "") or "").strip()
        act_hidden = str(actual.get("hidden_marker", "") or "").strip()
        if exp_hidden != act_hidden:
            differences.append(
                Difference(
                    index=idx,
                    field="hidden_marker",
                    expected=exp_hidden or "''",
                    actual=act_hidden or "''",
                )
            )

    extra_indices = sorted(set(actual_map.keys()) - {int(r.get("paragraph_index", -1)) for r in expected_rows})
    return differences, sorted(missing), extra_indices


def format_differences(differences: List[Difference], limit: int = 25) -> str:
    if not differences:
        return "  No numeric/string mismatches detected."

    lines = ["  Top differences (showing up to {}):".format(limit)]
    for diff in differences[:limit]:
        if diff.abs_delta is not None:
            lines.append(
                f"    ¬∂{diff.index:04d} field={diff.field}: expected {diff.expected}, actual {diff.actual} "
                f"(Œî={diff.abs_delta:.3f})"
            )
        else:
            lines.append(
                f"    ¬∂{diff.index:04d} field={diff.field}: expected {diff.expected}, actual {diff.actual}"
            )
    if len(differences) > limit:
        lines.append(f"    ... ({len(differences) - limit} more differences)")
    return "\n".join(lines)


def format_missing(missing: List[int], extra: List[int]) -> str:
    messages: List[str] = []
    if missing:
        preview = ", ".join(str(idx) for idx in missing[:15])
        suffix = "" if len(missing) <= 15 else f", ... ({len(missing)})"
        messages.append(f"  Missing indices in CSV: {preview}{suffix}")
    if extra:
        preview = ", ".join(str(idx) for idx in extra[:15])
        suffix = "" if len(extra) <= 15 else f", ... ({len(extra)})"
        messages.append(f"  Extra indices in CSV: {preview}{suffix}")
    return "\n".join(messages) if messages else ""


def main() -> None:
    parser = argparse.ArgumentParser(description="Audit paragraph indent regression against exported CSV data.")
    parser.add_argument("docx", type=Path, help="Path to the DOCX input file")
    parser.add_argument("csv", type=Path, help="Path to the CSV produced by export_paragraph_indents.py")
    parser.add_argument(
        "--tolerance",
        type=float,
        default=0.25,
        help="Tolerance in points for numeric comparisons (default: 0.25 pt)",
    )
    args = parser.parse_args()

    if not args.docx.exists():
        print(f"[ERROR] DOCX file not found: {args.docx}")
        sys.exit(1)
    if not args.csv.exists():
        print(f"[ERROR] CSV file not found: {args.csv}")
        sys.exit(1)

    print(f"üìÑ DOCX: {args.docx}")
    print(f"üìä CSV : {args.csv}")
    print(f"‚öôÔ∏è  Tolerance: {args.tolerance:.3f} pt")

    expected_rows = collect_paragraph_metrics(args.docx)
    actual_map = load_csv_rows(args.csv)

    diffs, missing, extra = compare_rows(expected_rows, actual_map, args.tolerance)

    print(f"\nTotal paragraphs (DOCX): {len(expected_rows)}")
    print(f"Total rows (CSV)       : {len(actual_map)}")
    print(f"Differences above tolerance: {len(diffs)}")

    if diffs:
        print(format_differences(diffs))
    if missing or extra:
        print(format_missing(missing, extra))

    if diffs or missing or extra:
        print("\n‚ùå Regression detected.")
        sys.exit(1)

    print("\n‚úÖ CSV matches DOCX-derived metrics within tolerance.")
    sys.exit(0)


if __name__ == "__main__":
    main()

